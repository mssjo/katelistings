#include "katelistings.hpp"

#include <getopt.h>

using namespace DOM;

void print_help() {
    std::cout << 
    "\n"
    "ABOUT:\n"
    "\n"
    "Katelistings  uses the syntax  highlighting  system of  the  Katepart-based\n"
    "family of editors to  produce code listings for LaTeX. This is less elegant\n"
    "than lstlistings and similar packages that live  inside LaTeX,  but has the\n"
    "following benefits:\n"
    " - The number  of supported languages is  much larger than for lstlistings,\n"
    "   since it leverages the work of the KDE community;\n"
    " - The  language  for  writing your  own  syntax  definitions is  much more\n"
    "   powerful and flexible than that of lstlistings;\n"
    " - The same custom  syntax works both  in LaTeX and  in all  Katepart-based\n"
    "   editors,  so the listings  have the same  look and feel  as the code you\n"
    "   write.\n"
    " - Your LaTeX system won't have to do any heavy lifting in the syntax high-\n"
    "   lighting, which should speed up typesetting.\n"
    "Note that this is my own  hobby project,  and not affiliated with Kate. The\n"
    "syntax highlighting engine itself is written from scratch by me,  but it is\n"
    "designed to work with the extensive syntax definition files  published with\n"
    "Kate.  I hope that the effort  I put into  piggy-backing off  of their work\n"
    "shows how much I appreciate it.\n"
    "\n"
    "COMMAND-LINE OPTIONS:\n"
    "\n"
    " -h [--help]                   Display this help message and exit.\n"
    " -g [--get-data]               Download all  Kate syntax and theme data and\n"
    "                                   process it  (which includes  running -m)\n"
    "                                   and exit. This must be done to set up or\n"
    "                                   update Katelistings.  Requires an Inter-\n"
    "                                   net connection.\n"
    " -m [--map-languages]          Run  the language mapping script  and  exit.\n"
    "                                   This is necessary everytime a new syntax\n" 
    "                                   definition has been added.\n"
    "\n"
    " -i [--input]                  Process the following file.  All extra argu-\n"
    "                                   ments are treated as input files just as\n"
    "                                   if they were the argument of -i.\n"
    " -s [--std-input]              Read  standard input  like an  -i file,  and\n"
    "                                   print the results to standard ouptut un-\n"
    "                                   less overridden with -o.\n"
    " -I [--inline]                 Read  the following LaTeX file,  and process\n"
    "                                   the contents of  all {katelistings}  en-\n"
    "                                   vironments and  \\katelisting macros con-\n"
    "                                   tained therein. Using the \"katelistings\"\n"
    "                                   package lets LaTeX replace the processed\n" 
    "                                   text with the syntax-highlighted output.\n"
    "                                   This  program  should be  rerun whenever\n"
    "                                   the listings are modified. The processed\n"
    "                                   files  are placed in  the \"katelistings\"\n" 
    "                                   unless overridden by -o.\n"
    " -S [--std-inline]             Read standard input like an -I file.\n"
    " -o [--output]                 Specifies a path  for the highlighted output\n"
    "                                   from  the  latest  input file  specified\n"
    "                                   with -iIsS. If no filename is given, the\n"
    "                                   default is <input filename>.lst.  For -I\n"
    "                                   and -S,  filenames are autogenerated, so\n"
    "                                   only the directory should be specified.\n"
    " -l [--language]               Specify that all input files  up to the next\n"
    "                                   -l or -L should be processed  as if they\n"
    "                                   are written  in the language  whose name\n" 
    "                                   is given,  regardless of what their file\n"
    "                                   extensions are.  Has no effect on inline\n"
    "                                   mode,  where languages are specified  in\n"
    "                                   LaTeX.\n"
    " -L [--default-language]       Returns to  the default mode  of determining\n"
    "                                   languages  based on file extensions,  as\n"
    "                                   provided in the syntax definition files.\n"
    "\n"
    " -t [--theme]                  Load a  highlighting theme  from  the speci-\n"
    "                                   fied .theme file.\n"
    "                                   (If omitted, the default theme is used.)\n"
    " -T [--default-theme]          Load a highlighting  theme as  with -t,  but\n"
    "                                   also  set it  as the default  for future\n"
    "                                   use of katelistings.\n"
    " -c [--commands]               Define LaTeX commands for all text styles in\n"
    "                                   a theme.  These  take  the  general form\n"
    "                                   \\<language><name>  (where <name>  is the\n"
    "                                   itemData name  used in  the syntax file,\n" 
    "                                   with whitespace removed) and are written\n"
    "                                   to \"<language>.lst.sty\"  placed together\n"
    "                                   with  all output files using this langu-\n"
    "                                   age.  This can be used with \\usepackage,\n"
    "                                   or with  \\kluselanguage in  inline-high-\n"
    "                                   lighted files.\n"
    "                                   This option  has two benefits:  it makes\n"
    "                                   .lst files shorter  and more human-read-\n"
    "                                   able, and allows for manual highlighting\n"
    "                                   of small code snippets  for which a full\n"
    "                                   listing won't work.\n"
    "\n"
    " -p [--ignore-priority]        Ignore the priority of language associations\n"
    "                                   to extensions. Instead, report ambiguity\n"
    "                                   whenever multiple languages  are associ-\n"
    "                                   ated with a file extension.\n"
    " -e [--echo-input]             Print the input lines as they are processed.\n"
    "                                   Useful as a progress indicator.\n"
    " -q [--quiet]                  Print nothing to standard output  (except as\n"
    "                                   specified by -h and -e). Does not affect\n"
    "                                   -g and -m, which are always verbose.\n"
    " -v [--verbose]                Print  more information  to  standard output\n"
    "                                   than usual.\n"
    " -d [--debug]                  Print lots and lots of information to stand-\n"
    "                                   ard output. Implies -v and -e.  Intended\n"
    "                                   for  debugging  custom syntax files,  or\n" 
    "                                   katelistings itself.\n"
    ;
   
    std::cout << std::endl;
    
}

std::string get_theme(const std::string& filename){
    std::string theme_path;
    
    if(filename.empty()){
        dom_element defaults;
        defaults.parse_xml("defaults.xml");
                
        theme_path = defaults.unique_element("defaults")
                                            .unique_element("theme")
                                            .attribute("path")
                                            .or_error("No default theme specified");
    }
    else
        theme_path = filename;
                                            
    theme_path = util::default_extension_and_dir(theme_path, ".theme", "themes/");
    
    if(!util::file_exists(theme_path)){
        std::cerr << "ERROR: Theme \"" << theme_path << "\" not found\n";
        exit(EXIT_FAILURE);
    }
    
    return theme_path;
}
    
void load_language_map(const dom_element& file, bool ignore_priority,
    std::unordered_map< std::string, util::cref_ptr<dom_element> >& languages, 
    std::unordered_map< std::string, std::list<std::string> >& extensions, 
    std::unordered_map< std::string, std::list<std::string> >& glob_extensions,
    print_options opts)
{    
    if(PRINT_OPT(DEBUG))
        file.print();
    
    for(const auto& lang : file.unique_element("language-map")
                               .unique_element("languages").or_error()
                               .all_elements("language"))
    {
        languages[lang.attribute("name").or_error()] = lang;
    }
    
    for(const auto& ext :  file.unique_element("language-map")
                               .unique_element("extensions").or_error()
                               .all_elements("extension"))
    {
        const std::string& e = ext.attribute("string").or_error();
        
        auto& list = ext.attribute("glob").or_default("false").bool_val() ? 
                glob_extensions[e] : extensions[e];
        
        int max_prio = ext.element("association").attribute("priority").or_error().int_val();
        for(const auto& ass : ext.all_elements("association")){
            if(ignore_priority || ass.attribute("priority").or_error().int_val() == max_prio)
                list.push_back( ass.attribute("language").or_error() );
            else
                break;
        }
    }
}

void overwrite_defaults(const std::string& theme_file, print_options opts){
    
    std::ofstream ost("defaults.xml");
    
    ost << "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n\n"
        << "<!-- default theme for katelistings -->\n\n"
        << "<defaults>\n"
        << "     <theme path=\"" << theme_file << "\" />\n"
        << "</defaults>" << std::endl;
        
    if(PRINT_OPT(DEBUG)){
        dom_element deflt;
        deflt.parse_xml("defaults.xml");
        deflt.print();
    }
}

int main(int argc, char** argv){
      
    std::cout << argv[0] << std::endl;
    
    latex_highlight highlight;
    
    bool overwrite_deflts = false;
    bool ignore_priority = false;
    
    print_options opts = NORMAL;
    
    //I opted for good ol' C-theme getopt here 
    //rather than doing something fancy.
    opterr = 1;
    const char* short_opts = "hgmi:sI:So:t:T:l:Lpqvedc";
    struct option long_opts[] = {
        {"help",                no_argument,        0, 'h'},
        {"get-data",            no_argument,        0, 'g'},
        {"map-languages",       no_argument,        0, 'm'},
        {"input",               required_argument,  0, 'i'},
        {"std-input",           no_argument,        0, 's'},
        {"inline",              required_argument,  0, 'I'},
        {"std-inline",          no_argument,        0, 'S'},
        {"output",              required_argument,  0, 'o'},
        {"language",            required_argument,  0, 'l'},
        {"default-language",    no_argument,        0, 'L'},
        {"theme",               required_argument,  0, 't'},
        {"default-theme",       required_argument,  0, 'T'},
        {"ingore-priority",     no_argument,        0, 'p'},
        {"echo-input",          no_argument,        0, 'e'},
        {"quiet",               no_argument,        0, 'q'},
        {"verbose",             no_argument,        0, 'v'},
        {"debug",               no_argument,        0, 'd'},
        {"commmands",           no_argument,        0, 'c'},
        {0,0,0,0}
    };
    
    std::list< katelistings_job > job_list;
    std::string theme_file = "", lang_name = "";
    
    //Handle all options in turn    
    while(true){
        int opt_idx = -1;
        int c = getopt_long(argc, argv, short_opts, long_opts, &opt_idx);
        
        if(c == -1)
            break;
                        
        switch(c){
            case 'h':
                print_help();
                return EXIT_SUCCESS;
                
            case 'g':
                system("./scripts/get_data.sh");
                //intentional fallthrough
            case 'm':
                system("./scripts/map_languages.sh");
                return EXIT_SUCCESS;
                
            case 'i':
                job_list.push_back( katelistings_job(optarg, lang_name, false) );
                break;
                
            case 's':
                job_list.push_back( katelistings_job("", lang_name, false) );
                break;
                
            case 'I':
                job_list.push_back( katelistings_job(optarg, lang_name, true) );
                break;
                
            case 'S':
                job_list.push_back( katelistings_job("", lang_name, true) );
                break;
                
            case 'o':
                if(!job_list.empty())
                    job_list.back().output_file = optarg;
                break;
                
            case 'l':
                lang_name = optarg;
                break;
                
            case 'L':
                lang_name = "";
                break;
                
            case 't':
                theme_file = optarg;
                break;
                
            case 'T':
                theme_file = optarg;
                overwrite_deflts = true;
                break;
                
            case 'p':
                ignore_priority = true;
                break;
                
            case 'e':
                opts = (print_options) (opts | print_options::ECHO_INPUT);
                break;
                
            case 'q':
                opts = (print_options) (opts & ~print_options::VERBOSITY);
                opts = (print_options) (opts | print_options::QUIET);
                break;
                
            case 'v':
                opts = (print_options) (opts & ~print_options::VERBOSITY);
                opts = (print_options) (opts | print_options::VERBOSE);
                break;
                
            case 'd':
                opts = (print_options) (opts & ~print_options::VERBOSITY);
                opts = (print_options) (opts | print_options::DEBUG);
                break;
            
            case 'c':
                opts = (print_options) (opts | print_options::USE_COMMANDS);
                break;
        }
    }
    
    for(; optind < argc; ++optind)
        job_list.push_back( katelistings_job(argv[optind], lang_name, false) );
    
      
    if(PRINT_OPT(NORMAL)){
        std::cout << "This is katelistings, version 0.3.1\n"
                  << "Written by Mattias Sjö 2021-01-26\n" 
                  << std::endl;
    }
    
    theme_file = get_theme(theme_file);
    highlight.parse_default_styles( theme_file, opts );
    if(overwrite_deflts)
        overwrite_defaults(theme_file, opts);
    
    std::unordered_map< std::string, util::cref_ptr<dom_element> > languages;
    std::unordered_map< std::string, std::list<std::string> > extensions;
    std::unordered_map< std::string, std::list<std::string> > glob_extensions;
    
    dom_element lang_map;
    lang_map.parse_xml("language_map.xml");
    
    load_language_map(lang_map, ignore_priority, languages, extensions, glob_extensions, opts);
        
    for(auto& job : job_list)
        highlight.do_job(job, languages, extensions, glob_extensions, opts);    
    
}
